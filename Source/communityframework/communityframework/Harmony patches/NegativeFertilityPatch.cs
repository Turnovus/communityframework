using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using HarmonyLib;
using Verse;
using RimWorld;

namespace CF
{
    /// <summary>
    /// Allows modders to use the <see cref="CF.UseNegativeFertility"/>
    /// <c>DefModExtension</c> to create plants which grow faster in poorer
    /// soil.
    /// </summary>
    /// <remarks>
    /// Generally mod-compatible and performant because of how it caches
    /// <c>MaxNaturalFertility</c>, but probably contributes to longer start-up
    /// times.
    /// </remarks>
    [StaticConstructorOnStartup]
    [ClassWithPatches("ApplyNegativeFertilityPatch")]
    static class NegativeFertilityPatch
    {
        public static float MaxNaturalFertility;

        /// <summary>
        /// Caches <c>MaxNaturalFertility</c> on startup by getting the most fertile natural terrain.
        /// </summary>
        /// <remarks>
        /// Where "natural" is defined as "generated by a <c>BiomeDef</c>". 
        /// </remarks>
        static NegativeFertilityPatch()
        {
            HashSet<TerrainDef> allPossibleNaturalTerrains =
                new HashSet<TerrainDef>();
            foreach (
                BiomeDef bd in DefDatabase<BiomeDef>.AllDefsListForReading
            )
            {
                foreach (TerrainThreshold tt in bd.terrainsByFertility)
                    allPossibleNaturalTerrains.Add(tt.terrain);

                foreach (TerrainPatchMaker tpm in bd.terrainPatchMakers)
                    foreach (TerrainThreshold tt in tpm.thresholds)
                        allPossibleNaturalTerrains.Add(tt.terrain);
            }
            IEnumerable<TerrainDef> terrainsByFertility = 
                from td in DefDatabase<TerrainDef>.AllDefsListForReading
                where allPossibleNaturalTerrains.Contains(td)
                orderby td.fertility descending
                select td;

            if (terrainsByFertility.EnumerableNullOrEmpty())
            {
                ULog.Error(
                    "Negative Fertility Patch: terrainsByFertility was empty. "
                    + "Setting EffectiveMaxFertility to 1."
                );
                MaxNaturalFertility = 1f;
            }
            else
            {
                MaxNaturalFertility = terrainsByFertility.First().fertility;
            }
        }

        [HarmonyPatch(
            typeof(Plant),
            nameof(Plant.GrowthRateFactor_Fertility),
            MethodType.Getter
        )]
        class NegativeFertilityPostfix
        {
            [HarmonyPostfix]
            public static void GrowthRateFactor_FertilityPostfix(
                ref float __result,
                ref Plant __instance
            )
            {
                UseNegativeFertility me;
                if (
                    (me = 
                        __instance.def.GetModExtension<UseNegativeFertility>())
                        != null
                 )
                {
                    float fertility = MaxNaturalFertility;
                    fertility -= __instance.Map.fertilityGrid.
                        FertilityAt(__instance.Position);
                    fertility *= __instance.def.plant.fertilitySensitivity;
                    fertility += 1f - __instance.def.plant.
                        fertilitySensitivity;

                    __result = Mathf.Clamp(
                        fertility,
                        me.minFertility, 
                        me.maxFertility
                    );
                }
            }
        }
    }
    
}